{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 01 – Visualize barcode drug signatures\n",
    "\n",
    "Notebook for downstream visualization of the barcode-based drug screen.\n",
    "\n",
    "Input:\n",
    "- `merged_logfc_pval_filtered_deseq2_2023_fillna.csv`: matrix of log2 fold-changes (one DESeq2 result per condition) already filtered on p-value and with missing values imputed.\n",
    "- `colnames_annotated_2023.csv`: annotation of conditions (drug, class, etc.).\n",
    "\n",
    "Outputs (saved in the `figures/` folder):\n",
    "- Heatmap of barcode signatures (barcodes × conditions).\n",
    "- Clustered correlation heatmap of conditions.\n",
    "- Drug similarity network (conditions as nodes, correlation-based edges).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "from pathlib import Path\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import networkx as nx\n",
    "from scipy.spatial.distance import squareform\n",
    "from scipy.cluster.hierarchy import linkage\n",
    "\n",
    "sns.set(context=\"notebook\", style=\"white\")\n",
    "plt.rcParams[\"figure.dpi\"] = 120\n",
    "\n",
    "# Ensure output directory exists\n",
    "FIG_DIR = Path(\"figures\")\n",
    "FIG_DIR.mkdir(parents=True, exist_ok=True)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Config – paths and parameters\n",
    "\n",
    "Adjust paths below if needed. They are written assuming:\n",
    "- this notebook lives in `scripts/2023/` (or similar),\n",
    "- data files live in `../data/` relative to the notebook.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "LOGFC_FILE: merged_logfc_pval_filtered_deseq2_2023_fillna.csv\n",
      "ANNOT_FILE: colnames_annotated_2023.csv\n",
      "Figures will be saved to: E:\\Downloads\\Projects\\2025_portfolio_github\\portfolio\\04_Postdoc_INSERM\\07_Barcodes\\notebooks\\figures\n"
     ]
    }
   ],
   "source": [
    "# ---- Paths (edit if needed) ----\n",
    "DATA_DIR = Path(\"../data\")\n",
    "SCRIPT_DIR = Path(\".\")\n",
    "\n",
    "LOGFC_FILE = SCRIPT_DIR / \"merged_logfc_pval_filtered_deseq2_2023_fillna.csv\"\n",
    "ANNOT_FILE = SCRIPT_DIR / \"colnames_annotated_2023.csv\"  # condition annotations\n",
    "\n",
    "# ---- Core parameters ----\n",
    "# Correlation threshold for network edges\n",
    "CORR_THRESHOLD = 0.8\n",
    "\n",
    "# Number of top variable barcodes to plot in Fig.3 (None = all)\n",
    "# You can set this to e.g. 3000 if the full matrix is too heavy to display.\n",
    "N_TOP_VARIABLE_BARCODES = None  # or an int\n",
    "\n",
    "print(\"LOGFC_FILE:\", LOGFC_FILE)\n",
    "print(\"ANNOT_FILE:\", ANNOT_FILE)\n",
    "print(\"Figures will be saved to:\", FIG_DIR.resolve())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Load log2FC matrix and annotation\n",
    "\n",
    "The log2FC file is expected to have:\n",
    "- rows: barcodes (or genomic features),\n",
    "- columns: conditions (CtrlMs_000u, Temps0_000u, drugs, doses, experiments, etc.),\n",
    "- all values: numeric log2 fold changes (after p-value filtering and imputation).\n",
    "\n",
    "The annotation file is expected to contain per-condition information (e.g. drug class).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'merged_logfc_pval_filtered_deseq2_2023_fillna.csv'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-8-ca7e9d0dd7e2>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Load log2FC matrix\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mlogfc_df\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mLOGFC_FILE\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msep\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m\";\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mheader\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mindex_col\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Original logFC shape (rows × cols):\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlogfc_df\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[1;31m# Ensure numeric, coerce non-numeric to NaN then fill with 0 (should already be numeric & imputed)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\util\\_decorators.py\u001b[0m in \u001b[0;36mwrapper\u001b[1;34m(*args, **kwargs)\u001b[0m\n\u001b[0;32m    309\u001b[0m                     \u001b[0mstacklevel\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mstacklevel\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    310\u001b[0m                 )\n\u001b[1;32m--> 311\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    312\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    313\u001b[0m         \u001b[1;32mreturn\u001b[0m \u001b[0mwrapper\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\readers.py\u001b[0m in \u001b[0;36mread_csv\u001b[1;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, error_bad_lines, warn_bad_lines, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options)\u001b[0m\n\u001b[0;32m    584\u001b[0m     \u001b[0mkwds\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mkwds_defaults\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    585\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 586\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0m_read\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    587\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    588\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\readers.py\u001b[0m in \u001b[0;36m_read\u001b[1;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[0;32m    480\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    481\u001b[0m     \u001b[1;31m# Create the parser.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 482\u001b[1;33m     \u001b[0mparser\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mTextFileReader\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    483\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    484\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mchunksize\u001b[0m \u001b[1;32mor\u001b[0m \u001b[0miterator\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\readers.py\u001b[0m in \u001b[0;36m__init__\u001b[1;34m(self, f, engine, **kwds)\u001b[0m\n\u001b[0;32m    809\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0moptions\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m\"has_index_names\"\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mkwds\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m\"has_index_names\"\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    810\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 811\u001b[1;33m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_engine\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_make_engine\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mengine\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    812\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    813\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mclose\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\readers.py\u001b[0m in \u001b[0;36m_make_engine\u001b[1;34m(self, engine)\u001b[0m\n\u001b[0;32m   1038\u001b[0m             )\n\u001b[0;32m   1039\u001b[0m         \u001b[1;31m# error: Too many arguments for \"ParserBase\"\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1040\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mmapping\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mengine\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mf\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0moptions\u001b[0m\u001b[1;33m)\u001b[0m  \u001b[1;31m# type: ignore[call-arg]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1041\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1042\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0m_failover_to_python\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\c_parser_wrapper.py\u001b[0m in \u001b[0;36m__init__\u001b[1;34m(self, src, **kwds)\u001b[0m\n\u001b[0;32m     49\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     50\u001b[0m         \u001b[1;31m# open handles\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 51\u001b[1;33m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_open_handles\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msrc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     52\u001b[0m         \u001b[1;32massert\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mhandles\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     53\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\parsers\\base_parser.py\u001b[0m in \u001b[0;36m_open_handles\u001b[1;34m(self, src, kwds)\u001b[0m\n\u001b[0;32m    227\u001b[0m             \u001b[0mmemory_map\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mkwds\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"memory_map\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mFalse\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    228\u001b[0m             \u001b[0mstorage_options\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mkwds\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"storage_options\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 229\u001b[1;33m             \u001b[0merrors\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mkwds\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"encoding_errors\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m\"strict\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    230\u001b[0m         )\n\u001b[0;32m    231\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\nina\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pandas\\io\\common.py\u001b[0m in \u001b[0;36mget_handle\u001b[1;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[0;32m    705\u001b[0m                 \u001b[0mencoding\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mioargs\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mencoding\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    706\u001b[0m                 \u001b[0merrors\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0merrors\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 707\u001b[1;33m                 \u001b[0mnewline\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m\"\"\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    708\u001b[0m             )\n\u001b[0;32m    709\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'merged_logfc_pval_filtered_deseq2_2023_fillna.csv'"
     ]
    }
   ],
   "source": [
    "# Load log2FC matrix\n",
    "logfc_df = pd.read_csv(LOGFC_FILE, sep=\";\", header=0, index_col=0)\n",
    "print(\"Original logFC shape (rows × cols):\", logfc_df.shape)\n",
    "\n",
    "# Ensure numeric, coerce non-numeric to NaN then fill with 0 (should already be numeric & imputed)\n",
    "logfc_df = logfc_df.apply(pd.to_numeric, errors=\"coerce\")\n",
    "logfc_df = logfc_df.fillna(0.0)\n",
    "\n",
    "# Sort columns case-insensitively, like in your correlation script\n",
    "logfc_df = logfc_df.reindex(sorted(logfc_df.columns, key=lambda x: x.lower()), axis=1)\n",
    "\n",
    "print(\"LogFC matrix after cleaning:\")\n",
    "display(logfc_df.iloc[:5, :8])\n",
    "\n",
    "# Load annotation of conditions (optional but highly recommended for nice plots)\n",
    "if ANNOT_FILE.exists():\n",
    "    annot_df = pd.read_csv(ANNOT_FILE, sep=\";\", header=True)\n",
    "    # First column is condition name\n",
    "    annot_df = annot_df.set_index(annot_df.columns[0])\n",
    "    print(\"Annotation columns:\", list(annot_df.columns))\n",
    "    # Reindex to match conditions in logfc_df (safe subset)\n",
    "    annot_df = annot_df.reindex(logfc_df.columns)\n",
    "else:\n",
    "    annot_df = None\n",
    "    print(\"Warning: annotation file not found – plots will be unannotated.\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Optional: restrict to top variable barcodes\n",
    "\n",
    "To avoid a gigantic heatmap, you can restrict to the most variable barcodes across conditions.\n",
    "If `N_TOP_VARIABLE_BARCODES` is `None`, all barcodes are used.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'logfc_df' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-9-0696ac8a6393>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      5\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34mf\"Using top {N_TOP_VARIABLE_BARCODES} most variable barcodes out of {logfc_df.shape[0]}.\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      6\u001b[0m \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 7\u001b[1;33m     \u001b[0mlogfc_sub\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlogfc_df\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      8\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Using all barcodes:\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlogfc_sub\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'logfc_df' is not defined"
     ]
    }
   ],
   "source": [
    "if N_TOP_VARIABLE_BARCODES is not None and N_TOP_VARIABLE_BARCODES < logfc_df.shape[0]:\n",
    "    variances = logfc_df.var(axis=1)\n",
    "    top_idx = variances.sort_values(ascending=False).head(N_TOP_VARIABLE_BARCODES).index\n",
    "    logfc_sub = logfc_df.loc[top_idx].copy()\n",
    "    print(f\"Using top {N_TOP_VARIABLE_BARCODES} most variable barcodes out of {logfc_df.shape[0]}.\")\n",
    "else:\n",
    "    logfc_sub = logfc_df.copy()\n",
    "    print(\"Using all barcodes:\", logfc_sub.shape[0])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Fig.3 – Heatmap of barcode signatures\n",
    "\n",
    "We reproduce the idea of your Fig.3:\n",
    "- rows: barcodes,\n",
    "- columns: conditions,\n",
    "- values: column-wise normalized log2FC (z-score per condition),\n",
    "- optional column annotation (drug classes, MOA, etc.).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'logfc_sub' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-10-62110d92c3a1>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Column-wise z-score (normalize each condition)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mz_logfc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlogfc_sub\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcopy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[0mz_logfc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mz_logfc\u001b[0m \u001b[1;33m-\u001b[0m \u001b[0mz_logfc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmean\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m/\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mz_logfc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstd\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mddof\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m+\u001b[0m \u001b[1;36m1e-9\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Z-scored logFC shape:\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mz_logfc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'logfc_sub' is not defined"
     ]
    }
   ],
   "source": [
    "# Column-wise z-score (normalize each condition)\n",
    "z_logfc = logfc_sub.copy()\n",
    "z_logfc = (z_logfc - z_logfc.mean(axis=0)) / (z_logfc.std(axis=0, ddof=0) + 1e-9)\n",
    "\n",
    "print(\"Z-scored logFC shape:\", z_logfc.shape)\n",
    "\n",
    "# Build annotation for seaborn, if available\n",
    "col_colors = None\n",
    "if annot_df is not None:\n",
    "    # Choose one annotation column for coloring (modify if needed)\n",
    "    # Example: a column named 'Class' or 'Mechanism' or similar.\n",
    "    # If several exist, you can change this variable.\n",
    "    annot_col_name = None\n",
    "    for candidate in [\"Class\", \"class\", \"DrugClass\", \"drug_class\", \"MOA\", \"moa\"]:\n",
    "        if candidate in annot_df.columns:\n",
    "            annot_col_name = candidate\n",
    "            break\n",
    "\n",
    "    if annot_col_name is not None:\n",
    "        cond_to_class = annot_df[annot_col_name].astype(str)\n",
    "        unique_classes = cond_to_class.unique()\n",
    "        palette = sns.color_palette(\"tab20\", n_colors=len(unique_classes))\n",
    "        class_to_color = {c: palette[i] for i, c in enumerate(unique_classes)}\n",
    "        col_colors = cond_to_class.map(class_to_color)\n",
    "        print(\"Using annotation column for colors:\", annot_col_name)\n",
    "    else:\n",
    "        print(\"No suitable annotation column found for color mapping.\")\n",
    "\n",
    "# Plot heatmap (rows not clustered, columns clustered or not as you prefer)\n",
    "plt.figure(figsize=(14, 8))\n",
    "sns.heatmap(\n",
    "    z_logfc,\n",
    "    cmap=\"RdBu_r\",\n",
    "    center=0,\n",
    "    cbar_kws={\"label\": \"normalized log2FC (z-score)\"},\n",
    "    xticklabels=False,\n",
    "    yticklabels=False\n",
    ")\n",
    "plt.title(\"Fig.3 – Barcode signatures (z-scored log2FC)\")\n",
    "plt.tight_layout()\n",
    "plt.savefig(FIG_DIR / \"fig3_barcode_signatures_heatmap.png\", dpi=300, bbox_inches=\"tight\")\n",
    "plt.savefig(FIG_DIR / \"fig3_barcode_signatures_heatmap.pdf\", bbox_inches=\"tight\")\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Fig.4 – Drug–drug correlation matrix\n",
    "\n",
    "We compute the Pearson correlation between conditions using the log2FC values and plot a clustered heatmap.\n",
    "\n",
    "- each column = one condition (drug/dose/experiment),\n",
    "- each cell = correlation between two conditions,\n",
    "- clustering on rows/columns gives the 2D drug map.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'logfc_df' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-11-6dd027562f74>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Correlation between conditions (columns)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mcorr_mat\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlogfc_df\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcorr\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmethod\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m\"pearson\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmin_periods\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Correlation matrix shape:\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mcorr_mat\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[1;31m# Clustered heatmap of correlations\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'logfc_df' is not defined"
     ]
    }
   ],
   "source": [
    "# Correlation between conditions (columns)\n",
    "corr_mat = logfc_df.corr(method=\"pearson\", min_periods=1)\n",
    "print(\"Correlation matrix shape:\", corr_mat.shape)\n",
    "\n",
    "# Clustered heatmap of correlations\n",
    "g = sns.clustermap(\n",
    "    corr_mat,\n",
    "    cmap=\"RdBu_r\",\n",
    "    vmin=-1,\n",
    "    vmax=1,\n",
    "    center=0,\n",
    "    figsize=(12, 12),\n",
    "    xticklabels=False,\n",
    "    yticklabels=False,\n",
    "    cbar_kws={\"label\": \"Pearson correlation\"},\n",
    "    method=\"complete\"\n",
    ")\n",
    "g.fig.suptitle(\"Fig.4 – Drug–drug correlation clustered heatmap\", y=1.02)\n",
    "plt.savefig(FIG_DIR / \"fig4_drug_drug_correlation_clustered.png\", dpi=300, bbox_inches=\"tight\")\n",
    "plt.savefig(FIG_DIR / \"fig4_drug_drug_correlation_clustered.pdf\", bbox_inches=\"tight\")\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Fig.5 – Drug network (correlation ≥ threshold)\n",
    "\n",
    "We build an undirected graph:\n",
    "- nodes = conditions,\n",
    "- edge between two nodes if their correlation ≥ `CORR_THRESHOLD` (default 0.8),\n",
    "- node color = drug class (if annotation available),\n",
    "- layout = Fruchterman–Reingold (spring layout), like in your original description.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'corr_mat' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-12-368b9b59abc2>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[1;31m# Add nodes with optional class attribute\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 5\u001b[1;33m \u001b[1;32mfor\u001b[0m \u001b[0mcond\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mcorr_mat\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcolumns\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      6\u001b[0m     \u001b[0mnode_attrs\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m{\u001b[0m\u001b[1;33m}\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      7\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mannot_df\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'corr_mat' is not defined"
     ]
    }
   ],
   "source": [
    "# Build graph from correlation matrix\n",
    "G = nx.Graph()\n",
    "\n",
    "# Add nodes with optional class attribute\n",
    "for cond in corr_mat.columns:\n",
    "    node_attrs = {}\n",
    "    if annot_df is not None:\n",
    "        # copy entire annotation row as attributes\n",
    "        if cond in annot_df.index:\n",
    "            for col in annot_df.columns:\n",
    "                node_attrs[col] = annot_df.loc[cond, col]\n",
    "    G.add_node(cond, **node_attrs)\n",
    "\n",
    "# Add edges based on correlation threshold\n",
    "for i, cond_i in enumerate(corr_mat.columns):\n",
    "    for j, cond_j in enumerate(corr_mat.columns):\n",
    "        if j <= i:\n",
    "            continue\n",
    "        r = corr_mat.loc[cond_i, cond_j]\n",
    "        if r >= CORR_THRESHOLD:\n",
    "            G.add_edge(cond_i, cond_j, weight=float(r))\n",
    "\n",
    "print(\"Number of nodes:\", G.number_of_nodes())\n",
    "print(\"Number of edges (|r| >=\", CORR_THRESHOLD, \"):\", G.number_of_edges())\n",
    "\n",
    "# Choose node colors from a class attribute if available\n",
    "node_classes = None\n",
    "if annot_df is not None:\n",
    "    for candidate in [\"Class\", \"class\", \"DrugClass\", \"drug_class\", \"MOA\", \"moa\"]:\n",
    "        if candidate in annot_df.columns:\n",
    "            node_classes = candidate\n",
    "            break\n",
    "\n",
    "if node_classes is not None:\n",
    "    class_values = []\n",
    "    for n in G.nodes:\n",
    "        if n in annot_df.index:\n",
    "            class_values.append(str(annot_df.loc[n, node_classes]))\n",
    "        else:\n",
    "            class_values.append(\"NA\")\n",
    "    unique_classes = sorted(set(class_values))\n",
    "    palette = sns.color_palette(\"tab20\", n_colors=len(unique_classes))\n",
    "    class_to_color = {c: palette[i] for i, c in enumerate(unique_classes)}\n",
    "    node_colors = [class_to_color[c] for c in class_values]\n",
    "else:\n",
    "    node_colors = \"tab:blue\"\n",
    "    unique_classes = None\n",
    "    class_to_color = None\n",
    "    print(\"No class annotation found for node coloring.\")\n",
    "\n",
    "# Spring layout (Fruchterman–Reingold)\n",
    "pos = nx.spring_layout(G, seed=42)\n",
    "\n",
    "plt.figure(figsize=(10, 10))\n",
    "nx.draw_networkx_edges(G, pos, alpha=0.3, width=0.5)\n",
    "nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=80, linewidths=0.5, edgecolors=\"black\")\n",
    "nx.draw_networkx_labels(G, pos, font_size=4)\n",
    "\n",
    "plt.title(f\"Fig.5 – Drug similarity network (r ≥ {CORR_THRESHOLD})\")\n",
    "plt.axis(\"off\")\n",
    "plt.tight_layout()\n",
    "plt.savefig(FIG_DIR / \"fig5_drug_network.png\", dpi=300, bbox_inches=\"tight\")\n",
    "plt.savefig(FIG_DIR / \"fig5_drug_network.pdf\", bbox_inches=\"tight\")\n",
    "plt.show()\n",
    "\n",
    "# Optional: legend for classes\n",
    "if unique_classes is not None and class_to_color is not None:\n",
    "    fig, ax = plt.subplots(figsize=(4, 4))\n",
    "    for c in unique_classes:\n",
    "        ax.scatter([], [], color=class_to_color[c], label=c, s=40)\n",
    "    ax.legend(title=node_classes, frameon=False, fontsize=6)\n",
    "    ax.set_axis_off()\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(FIG_DIR / \"fig5_drug_network_legend.png\", dpi=300, bbox_inches=\"tight\")\n",
    "    plt.savefig(FIG_DIR / \"fig5_drug_network_legend.pdf\", bbox_inches=\"tight\")\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Quick summary\n",
    "\n",
    "This notebook:\n",
    "- loads `merged_logfc_pval_filtered_deseq2_2023_fillna.csv`,\n",
    "- optionally restricts to the most variable barcodes,\n",
    "- generates three main figures:\n",
    "  1. **Fig.3** – barcode signatures heatmap,\n",
    "  2. **Fig.4** – clustered correlation heatmap of conditions,\n",
    "  3. **Fig.5** – correlation-based drug similarity network.\n",
    "\n",
    "All figures are saved in the `figures/` folder as both `.png` and `.pdf`.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
