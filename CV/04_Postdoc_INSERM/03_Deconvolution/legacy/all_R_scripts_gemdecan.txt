
RNAsign_functions.R 
### To do different gene expression by limma package

DGEs <- function(data, Phenotype, lFC, FDR) {
  require(limma)
  require(dplyr)
  # require(dendextend)


  message("[===========================]")
  message("[<<<<<<< DGEs START >>>>>>>>>]")
  message("[<<<< Pairwise analysis >>>>>]")
  message("------------------------------")

  # This function creates the pairs for the pairwise matrices
  design.pairs <- function(levels) {
    n <- length(levels)
    design <- matrix(0, n, choose(n, 2))
    rownames(design) <- levels
    colnames(design) <- 1:choose(n, 2)
    k <- 0
    for (i in 1:(n - 1)) {
      for (j in (i + 1):n) {
        k <- k + 1
        design[i, k] <- 1
        design[j, k] <- -1
        colnames(design)[k] <- paste(levels[i], "-", levels[j], sep = "")
      }
    }
    design
  }

  # This function creates the pairs for the pairwise matrices

  design <- model.matrix(~ 0 + Phenotype)
  contr.matrix <- design.pairs(levels(factor(Phenotype)))
  colnames(design) <- rownames(contr.matrix)

  # Removing heteroscedascity from data
  v <- voom(log2(data + 1), design, plot = F)

  # Fitting linear models for comparisons of interest
  Fit <- lmFit(v, design) %>%
    contrasts.fit(., contr.matrix) %>%
    eBayes(.) %>%
    treat(., lfc = lFC)

  # this code includes list of DEGs for pairwise comparisons
  FitList <- list()
  for (i in 1:ncol(contr.matrix)) {
    FitList[[i]] <- topTreat( Fit[ which( decideTests( Fit)[, i] != 0), ], coef = i, adjust.method = "BH", number = nrow(v$E) ) %>%
      mutate(ID = rownames(.)) %>%
      filter(., adj.P.Val < FDR)
  }

  names(FitList) <- colnames(contr.matrix)
  message("thank you for waiting")
  return(FitList)
}

### To do signature ###

Signfeature <- function(data_TPM, Phenotype, FitList, FCcuoff, MaxDMRs) {
  require(dplyr)
  require(matrixStats)
  require(limma)

  message("[===========================]")
  message("[<<<< Signature START >>>>>]")
  message("-----------------------------")

  # design <- model.matrix(~0 + Phenotype)
  # v_expr <- voom(data, design, plot = FALSE)

  # using positive FC (=over-expressed in cell type of interest)
  # FitList is DGEs which calculate by DGEs function

  #this code explained how to choose the genes for final signature gens
  A1 <- list()
  for (i in 1:length(FitList)) {
    A1[[i]] <- filter(FitList[[i]], abs(logFC) > FCcuoff) %>% arrange(., desc(logFC)) # %>% top_n(ceiling(n()*0.5), wt = logFC)
    if (nrow(A1[[i]]) > MaxDMRs) {
      A1[[i]] <- A1[[i]][1:MaxDMRs, ]
    }
  }


  sig <- lapply(A1, function(x) dplyr::select(x, ID))
  sig <- do.call(rbind, sig)
  sig <- filter(sig, !duplicated(ID))
  data1 <- data_TPM[rownames(data_TPM) %in% sig$ID, ]

  # Print number of selected probes (signature)
  nrow(data1)

  result <- getMedVal(data1, Phenotype)
  message("[===========================]")
  message("[<<<< Signature END >>>>>]")
  message("-----------------------------")
  return(result)
}

### Function to get median value of each gene from an input dataframe ###

getMedVal <- function(data, Phenotype) {
  library(matrixStats)

  Trans <- data.frame(t(data))
  Mt.Split <- split(Trans, Phenotype)
  Mt.Split <- lapply(Mt.Split, function(x) colMedians(data.matrix(x)))
  Mt.Split <- do.call(cbind, Mt.Split)
  rownames(Mt.Split) <- rownames(data)
  return(Mt.Split)
}

### To choose suitable threshold of LogFC (save as PDF file)

DGEs.QC <- function(FitList, FDR) {
  require(ggpubr)

  p <- list()

  for (i in 1:length(FitList)) {
    p[[i]] <- ggplot(FitList[[i]][FitList[[i]]$adj.P.Val < FDR, ], aes(x = logFC)) +
      geom_density(colour = "red") +
      labs(title = names(FitList)[i], x = "logFC", y = "Density") +
      theme(plot.title = element_text(hjust = 0.5))
  }
  return(do.call(ggarrange, p))
}


getExpMatrix <- function(geneList, expression) {
  df_out <- expression[geneList, ]
  return(df_out)
}

fpkm2tpm <- function(fpkm) {
  tpm <- exp(log(fpkm) - log(sum(fpkm, na.rm = T)) + log(1e6))
  tpm[is.na(tpm)] <- 0
  return(tpm)
}

TPM_normalization <- function(data) {

  # TPM normalization

  TPM_data <- t(t(data) * 1e6 / apply(data, 2, sum))
  return(TPM_data)
}

compute_geneLength.R 
suppressMessages({
  require(tximport)
  require(org.Hs.eg.db)
  require(TxDb.Hsapiens.UCSC.hg38.knownGene)
  require(Organism.dplyr)
  require(tidyverse)
})

# Convert ENST to HUGO symbols, quantif.sf is the output from Salmon
src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene")
src <- src_ucsc("Homo sapiens")
k <- keys(src, keytype = "tx_id")
tx2gene<- select(src, keys = k, columns = c("tx_name","symbol"), keytype = "entrez")
tx2gene<-tx2gene[,-1]
txi <- tximport("quant.sf", type = "salmon", tx2gene = tx2gene)
write_tsv(as.data.frame(cbind(Gene=rownames(txi[[3]]), floor(txi[[3]]) )), "gene_length.txt")

count_to_tpm.R 
if (!require(tidyverse)) {
  install.packages("tidyverse")
}
library(tidyverse)

# HTseq-count outputs a file with a gene count. This is not suitable for deconvolution for many reasons,
# so we convert it to TPM, like Kallisto and Salmon does

setwd(snakemake@params[[1]])
sample <- basename(getwd())

counts.df <- read_tsv("count_quantif.txt", col_names = F)
names(counts.df) <- c("gene_name", "HTseq")
gene.length <- read_tsv(snakemake@params[[2]])
meanFragmentLength <- snakemake@params[[3]]

counts.df <- inner_join(counts.df, gene.length, by = c("gene_name" = "Gene"))
counts.df[, 3] <- floor(counts.df[, 3])

# in order to convert values, we need the length of each gene and  the mean size of sequenced fragments
counts_to_tpm <- function(counts, featureLength, meanFragmentLength) {

  # Ensure valid arguments.
  stopifnot(nrow(featureLength) == nrow(counts))
  stopifnot(length(meanFragmentLength) == ncol(counts))

  # Compute effective lengths of features in each library.
  effLen <- do.call(cbind, lapply(1, function(i) {
    featureLength - meanFragmentLength[i] + 1
  }))

  # Exclude genes with length less than the mean fragment length.
  idx <- apply(effLen, 1, function(x) min(x) > 1)
  counts <- counts[idx, ]
  effLen <- effLen[idx, ]
  featureLength <- featureLength[idx, ]

  # Process one column at a time.
  counts <- as.data.frame(counts)
  effLen <- as.data.frame(effLen)
  tpm <- do.call(cbind, lapply(1, function(i) {
    rate <- log(counts[, i]) - log(effLen[, i])
    denom <- log(sum(exp(rate)))
    exp(rate - denom + log(1e6))
  }))

  # Copy the column names from the original matrix.
  tpm <- cbind(Gene = rownames(counts), tpm)
  return(tpm)
}

featureLength <- counts.df[, 3]
counts <- as.matrix(counts.df[, 2])
rownames(counts) <- counts.df$gene_name

TPM.from.HTSeq <- counts_to_tpm(counts, featureLength, meanFragmentLength)
colnames(TPM.from.HTSeq) <- c("Gene", sample)
TPM.from.HTSeq %>%
  as.data.frame() %>%
  write_tsv("quantif.txt")

deconvolution_algorithms.R 
# install.packages(c("remotes", "devtools", "dplyr", "tidyr", "readr", "stringr", "magrittr", "purrr"))
# BiocManager::install(c("EpiDISH", "DeconRNASeq"))
# devtools::install_github("ebecht/MCPcounter",ref="master", subdir="Source")
# remotes::install_github("icbi-lab/immunedeconv")
# devtools::install_github('dviraran/xCell')

# Load required libraries
suppressPackageStartupMessages({
  library(dplyr) # rename
  library(tidyr) # pivot_longer
  library(readr) # read_tsv read_csv write_tsv
  library(stringr) # str_c
  library(magrittr) # %<>%
  library(EpiDISH) # epidish
  library(MCPcounter) # MCPcounter.estimate
  library(immunedeconv) # deconvolute
  library(DeconRNASeq) # DeconRNASeq
  library(purrr) # reduce
  library(xCell) # xCell
})

computeQuantiseq <- function(TPM_matrix) {
  quantiseq <- as_tibble(deconvolute(TPM_matrix, "quantiseq")) %>%
    pivot_longer(-cell_type) %>%
    pivot_wider(names_from = cell_type, values_from = value) %>%
    dplyr::rename(sample = name)

  colnames(quantiseq)[-1] <- str_c("Quantiseq_", colnames(quantiseq)[-1])
  colnames(quantiseq) <- sapply(colnames(quantiseq), . %>% {
    str_replace_all(., " ", "_")
  })
  quantiseq
}

computexCell <- function(TPM_matrix) {
  xcell <- xCellAnalysis(as.data.frame(TPM_matrix)) %>%
    as_tibble(rownames = "cell_type") %>%
    pivot_longer(-cell_type) %>%
    pivot_wider(names_from = cell_type) %>%
    dplyr::rename(sample = name)

  colnames(xcell)[-1] <- str_c("XCELL_", colnames(xcell)[-1])
  colnames(xcell) <- sapply(colnames(xcell), . %>% {
    str_replace_all(., " ", "_")
  })
  xcell
}

computeMCP <- function(TPM_matrix) {
  genes <- read.table("./signatures/MCPcounter/MCPcounter-genes.txt", sep = "	", stringsAsFactors = FALSE, header = TRUE, colClasses = "character", check.names = FALSE)
  mcp <- MCPcounter.estimate(TPM_matrix, genes = genes, featuresType = "HUGO_symbols", probesets = NULL)
  mcp <- as_tibble(MCPcounter.estimate(TPM_matrix, genes = genes, featuresType = "HUGO_symbols", probesets = NULL), rownames = "cell_type") %>%
    pivot_longer(-cell_type) %>%
    pivot_wider(names_from = cell_type, values_from = value) %>%
    dplyr::rename(sample = name)

  colnames(mcp)[-1] <- str_c("MCP_", colnames(mcp)[-1])
  colnames(mcp) <- sapply(colnames(mcp), . %>% {
    str_replace_all(., " ", "_")
  })
  mcp
}
methods_with_variable_signatures <- function(TPM_matrix, signature_files) {
  TPM_df <- as.data.frame(TPM_matrix)
  all_methods_and_signatures <- lapply(signature_files, function(signature_file) {
    signature <- as.matrix(read.table(signature_file, header = TRUE, row.names = 1, sep = "	"))

    signature_name <- basename(signature_file)
    signature_name <- str_split(signature_name, "\.")[[1]][1]

    epi <- epidish(TPM_matrix, signature, method = "RPC", maxit = 200)
    epi <- as_tibble(epi$estF, rownames = "sample")
    colnames(epi)[-1] <- str_c("Epidish", signature_name, colnames(epi)[-1], sep = "_")
    colnames(epi) <- sapply(colnames(epi), . %>% {
      str_replace_all(., " ", "_")
    })

    decon <- DeconRNASeq(TPM_df, as.data.frame(signature))
    decon <- bind_cols(colnames(TPM_df), as_tibble(decon$out.all)) %>% dplyr::rename(sample = ...1)
    colnames(decon)[-1] <- str_c("DeconRNASeq", signature_name, colnames(decon)[-1], sep = "_")
    colnames(decon) <- sapply(colnames(decon), . %>% {
      str_replace_all(., " ", "_")
    })

    inner_join(epi, decon, by = "sample")
  })
  reduce(all_methods_and_signatures, inner_join, "sample")
}

deconvolutions <- function(TPM_matrix) {
  signature_files <- list.files("./signatures", full.names = T)
  signature_files <- setdiff(signature_files, signature_files[dir.exists(signature_files)])

  all_deconvolutions_table <- lapply(c("Quantiseq", "MCP", "xCell", "rest"), function(method) {
    if (method == "Quantiseq") {
      computeQuantiseq(TPM_matrix)
    } else if (method == "xCell") {
      computexCell(TPM_matrix)
    } else if (method == "MCP") {
      computeMCP(TPM_matrix)
    } else if (method == "rest") {
      methods_with_variable_signatures(TPM_matrix, signature_files)
    }
  })


  all_deconvolutions_table %<>% reduce(inner_join, "sample")
  all_deconvolutions_table_m <- as.matrix(all_deconvolutions_table[,-1])
  rownames(all_deconvolutions_table_m) <- all_deconvolutions_table %>% pull(1)
  all_deconvolutions_table_m
}

deconvolution_deconrnaseq.R 
require(DeconRNASeq)

signature <- read.table(snakemake@params[[1]], header = TRUE, row.names = 1)
t1 <- read.table(snakemake@input[[1]], header = TRUE, row.names = 1)
# signature need to be formated to the correct input format for deconrna, as it is picky
res <- DeconRNASeq(t1, signature)
Fres <- as.data.frame(res$out.all)
Fres <- cbind(Sample = colnames(t1), Fres)
Fres[, -1] <- round(Fres[, -1], 3)
write.table(Fres, snakemake@output[[1]], sep = "	", quote = F, row.names = F, col.names = T)

deconvolution_epidish.R 
require(EpiDISH)

signature <- as.matrix(read.table(snakemake@params[[1]], header = TRUE, row.names = 1))
t1 <- read.table(snakemake@input[[1]], header = TRUE, row.names = 1)

res <- epidish(t1, signature, method = "RPC")
Fres <- as.data.frame(res$estF)
Fres <- cbind(Sample = rownames(Fres), Fres)
Fres[, -1] <- round(Fres[, -1], 3)

write.table(Fres, snakemake@output[[1]], sep = "	", quote = F, row.names = F, col.names = T)

deconvolution_mcpcounter.R 
install.packages(c("devtools", "curl"))
require(devtools)
install_github("ebecht/MCPcounter", ref = "master", subdir = "Source")
require(MCPcounter)

t1 <- as.matrix(read.table(snakemake@input[[1]], header = TRUE, row.names = 1))
res_mcp <- MCPcounter.estimate(t1,
  featuresType = "HUGO_symbols",
  genes = read.table(snakemake@params[[1]], sep = "	", stringsAsFactors = FALSE, header = TRUE, colClasses = "character", check.names = FALSE)
)
res_mcp[] <- round(res_mcp[], 3)
res_mcp <- t(res_mcp)
res_mcp <- rbind(Sample = colnames(res_mcp), res_mcp)
write.table(res_mcp, snakemake@output[[1]], sep = "	", quote = F, row.names = T, col.names = F)

deconvolution_quantiseq.R 
require(immunedeconv)

t1 <- as.matrix(read.table(snakemake@input[[1]], header = TRUE, row.names = 1))
res <- deconvolute(t1, "quantiseq")
res[, -1] <- round(res[, -1], 3)
res <- t(res)
write.table(res, snakemake@output[[1]], sep = "	", quote = F, row.names = T, col.names = F)

merge_deconv.R 
sample = read.table(snakemake@input[[1]], sep="	", header=TRUE)

if (!file.exists(snakemake@params[[1]])){
merge = data.frame(t(sample))
  } else{
  merge = t(read.table(snakemake@params[[1]], sep="	", header=TRUE))
  merge = rbind(merge, sample[2,, drop=FALSE])
}

write.table(merge, snakemake@params[[1]], sep= "	", quote=F, row.names = F)

merge_quantif.R 
sample <- snakemake@input

merge <- read.table(sample[[1]], sep = "	", header = T)
for (i in 2:length(sample)) {
  x <- read.table(sample[[i]], sep = "	", header = T)
  merge <- merge(merge, x, by="Gene")
}

write.table(merge, snakemake@output[[1]], sep = "	", quote = F, row.names = F)

quant_for_kallisto.R 
suppressMessages({
  require(tximport)
  require(org.Hs.eg.db)
  require(TxDb.Hsapiens.UCSC.hg38.knownGene)
  require(Organism.dplyr)
})
setwd(snakemake@params[[1]])
sample = basename(getwd())

src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene")
src <- src_ucsc("Homo sapiens")
k <- keys(src, keytype = "tx_id")
tx2gene<- select(src, keys = k, columns = c("tx_name","symbol"), keytype = "entrez")
tx2gene<-tx2gene[,-1]
txi <- tximport("abundance.h5", type = "kallisto", tx2gene = tx2gene, txIn=TRUE)
txi_data<-as.data.frame(cbind(Gene=rownames(txi[[1]]), txi[[1]]))
colnames(txi_data) = c("Gene",sample)
write.table(txi_data, "quantif.txt", sep="	", quote=F, row.names = F)

quant_for_salmon.R 
suppressMessages({
  require(tximport)
  require(org.Hs.eg.db)
  require(TxDb.Hsapiens.UCSC.hg38.knownGene)
  require(Organism.dplyr)
})
setwd(snakemake@params[[1]])
sample = basename(getwd())

src <- src_organism("TxDb.Hsapiens.UCSC.hg38.knownGene")
src <- src_ucsc("Homo sapiens")
k <- keys(src, keytype = "tx_id")
tx2gene<- select(src, keys = k, columns = c("tx_name","symbol"), keytype = "entrez")
tx2gene<-tx2gene[,-1]
txi <- tximport("quant.sf", type = "salmon", tx2gene = tx2gene)
txi_data<-as.data.frame(cbind(Gene=rownames(txi[[1]]), txi[[1]]))
colnames(txi_data) = c("Gene",sample)
write.table(txi_data, "quantif.txt", sep="	", quote=F, row.names = F)
